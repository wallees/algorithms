/* 백준 2869, 달팽이는 올라가고 싶다 : https://www.acmicpc.net/problem/2869 */

#include <iostream>
using namespace std;

/*
 이진트리용 문제라고 적어놓았는데, 사실 식만 제대로 세우면 굳이 이진트리로 안풀어도 됩니다.
 앞으로 가는 거리를 A, 뒤로 돌아가는 거리를 B, 총 움직여야 하는 거리를 V라고 할 때,
 결국 최종 이동해야 하는 거리는 다음과 같습니다.
 
 "(V - B) / (A - B)"
 
 문제는, 정확하게 떨어지지 않는 경우가 발생한다는 것이죠.
 예를 들어 **가 앞으로 이동한 거리, *가 뒤로 움직여서 실제로 이동한 거리라고 할 때,
 
 1. A가 3, B가 1, V가 5면
 [*][*][**][ ][ ] -> [*][*][*][*][**] 이므로 2번만에 이동이 가능합니다.
 
 하지만
 2. A가 4, B가 1, V가 5면
 [*][*][*][**][ ] -> [*][*][*][*][*]... 로 실제로는 나누어지지 않고 넘치게(덜 가게) 되죠.
 
 그러므로 최종 결과 값이 정확하게 떨어지지 않는 경우 +1 만 해주면 됩니다.
 */
int main(void)
{
    /*
     a: 올라 가는 거리
     b: 내려 가는 거리
     v: 나무 막대 높이
     result: 꼭대기까지 올라가는데 걸린 날짜입니다.
     중요한 것은 값의 범위가 1부터 1,000,000,000이므로 long long 타입을 사용해야 합니다.
     */
    long long int a, b, v, result, cal;
    cin>>a>>b>>v;
    
    // 전체 이동한 날짜를 먼저 구합니다. 조금 남은 여부를 확인하지 않은 상태죠.
    result = (v - b) / (a - b);
    // 만약 더 가야하는 거리가 남았다면 1을 더해줍니다.
    if((v - b) % (a - b)) result += 1;

    cout<<result<<endl;
    return 0;
}
