# 16928. ë±€ê³¼ ì‚¬ë‹¤ë¦¬ ê²Œì„

## Summary

ğŸ™‡â€â™‚ï¸ URL : https://www.acmicpc.net/problem/16928  
ğŸ¤·â€â™‚ï¸ Difficulty: ?  
ğŸ’†â€â™‚ï¸ Submissions : Success

## Source code

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class App {

    static int M, N;
    static int[] next = new int[101];   // ë‹¤ìŒ ì´ë™ ì¥ì†Œ
    static int[] dist = new int[101];   // ìµœì†Œ ì´ë™ ê±°ë¦¬
    

    public static void main(String[] args) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        // ì²«ì§¸ ì¤„ì— ê²Œì„íŒì— ìˆëŠ” ì‚¬ë‹¤ë¦¬ì˜ ìˆ˜ N(1 â‰¤ N â‰¤ 15)ê³¼ ë±€ì˜ ìˆ˜ M(1 â‰¤ M â‰¤ 15)ì´ ì£¼ì–´ì§„ë‹¤.
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        for(int i=0; i<next.length; i++) {
            next[i] = i;
            dist[i] = -1;
        }

        // ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì—ëŠ” ì‚¬ë‹¤ë¦¬ì˜ ì •ë³´ë¥¼ ì˜ë¯¸í•˜ëŠ” x, y (x < y)ê°€ ì£¼ì–´ì§„ë‹¤. 
        // xë²ˆ ì¹¸ì— ë„ì°©í•˜ë©´, yë²ˆ ì¹¸ìœ¼ë¡œ ì´ë™í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.
        for(int i=0; i<N; i++) {
            String[] ladders = br.readLine().split(" ");
            next[Integer.parseInt(ladders[0])] = Integer.parseInt(ladders[1]);
        }

        // ë‹¤ìŒ Mê°œì˜ ì¤„ì—ëŠ” ë±€ì˜ ì •ë³´ë¥¼ ì˜ë¯¸í•˜ëŠ” u, v (u > v)ê°€ ì£¼ì–´ì§„ë‹¤. 
        // uë²ˆ ì¹¸ì— ë„ì°©í•˜ë©´, vë²ˆ ì¹¸ìœ¼ë¡œ ì´ë™í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.
        for(int i=0; i<M; i++) {
            String[] snakes = br.readLine().split(" ");
            next[Integer.parseInt(snakes[0])] = Integer.parseInt(snakes[1]);
        }

        // ê²Œì„ì˜ ëª©í‘œëŠ” 1ë²ˆ ì¹¸ì—ì„œ ì‹œì‘í•´ì„œ 100ë²ˆ ì¹¸ì— ë„ì°©í•˜ëŠ” ê²ƒì´ë‹¤.
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);
        dist[1] = 0;

        // 100ë²ˆ ì¹¸ì— ë„ì°©í•˜ê¸° ìœ„í•´ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ì•¼ í•˜ëŠ” íšŸìˆ˜ì˜ ìµœì†Ÿê°’ì„ êµ¬í•´ë³´ì.
        System.out.println(solution(queue));
    }

    public static int solution(Queue<Integer> queue) {
        
        while(!queue.isEmpty()) {
            int location = queue.poll();
            for(int i=1; i<=6; i++) {
                int nextLocation = location + i;

                // ë§Œì•½ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦° ê²°ê³¼ê°€ 100ë²ˆ ì¹¸ì„ ë„˜ì–´ê°„ë‹¤ë©´ ì´ë™í•  ìˆ˜ ì—†ë‹¤.
                if(nextLocation <= 100) {

                    // ì‚¬ë‹¤ë¦¬ í˜¹ì€ ë±€ì´ ì¡´ì¬í•œë‹¤ë©´, í•´ë‹¹ ìœ„ì¹˜ë¡œ ì´ë™
                    // ë§Œì•½ ì—†ë‹¤ë©´ ìê¸° ìì‹ ì´ ê·¸ëŒ€ë¡œ ê°’ì´ ë  ê²ƒì´ë‹¤.
                    nextLocation = next[nextLocation];
                    
                    // ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ìš° -> ì´ë™íšŸìˆ˜ + 1
                    // BFS -> ê°€ì¥ ë¨¼ì € í•´ë‹¹ ì¹¸ì„ ë°©ë¬¸í–ˆë‹¤ = ê°€ì¥ ì ì€ íšŸìˆ˜ë¡œ í•´ë‹¹ ì¹¸ìœ¼ë¡œ ì´ë™í–ˆë‹¤ëŠ” ì˜ë¯¸
                    if(dist[nextLocation] < 0) {
                        dist[nextLocation] = dist[location] + 1;
                        queue.offer(nextLocation);
                    }
                }
            }
        }

        // 100ë²ˆì§¸ ì¹¸ì˜ ì´ë™ íšŸìˆ˜ë¥¼ ì¶œë ¥
        return dist[100];
    }
}

```

## How to Approach

### 1. ë¬¸ì œ í•µì‹¬, ëª©í‘œ
ë³¸ ë¬¸ì œì˜ í•µì‹¬ì€ '100ë²ˆ ì¹¸ì— ë„ì°©í•˜ê¸° ìœ„í•´ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ì•¼ í•˜ëŠ” íšŸìˆ˜ì˜ ìµœì†Ÿê°’'ì„ êµ¬í•˜ëŠ” ê²ƒì´ë‹¤.

### 2. 10 x 10 => 100ê°œì˜ ë°°ì—´ë¡œ

ì´ ë¬¸ì œì—ì„œëŠ” ë‘ ê°œì˜ ë°°ì—´ì„ ë§Œë“¤ì—ˆë‹¤.
- ë±€ ë˜ëŠ” ì‚¬ë‹¤ë¦¬ì˜ ì •ë³´ê°€ ì í˜€ìˆëŠ” ë°°ì—´. ë‹¤ë¥´ê²Œ ë§í•˜ë©´ "í˜„ì¬ì— ë¨¸ë¬¼ëŸ¬ì•¼ í• ì§€, í˜¹ì€ í•œë²ˆ ë” ë‹¤ë¥¸ ì¹¸ìœ¼ë¡œ ì´ë™í•´ì•¼ í•˜ëŠ”ì§€ ì í˜€ìˆëŠ”" ë°°ì—´
- í˜„ì¬ ìœ„ì¹˜ê¹Œì§€ ì´ë™í•œ ê°€ì¥ ì ì€ íšŸìˆ˜ë¥¼ ë‹´ê³  ìˆëŠ” ë°°ì—´

```java
static int[] next = new int[101];   // ë‹¤ìŒ ì´ë™ ì¥ì†Œ
static int[] dist = new int[101];   // ìµœì†Œ ì´ë™ ê±°ë¦¬
...

for(int i=0; i<101; i++) {
    next[i] = i;  
    dist[i] = -1;
}
...
// ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì—ëŠ” ì‚¬ë‹¤ë¦¬ì˜ ì •ë³´ë¥¼ ì˜ë¯¸í•˜ëŠ” x, y (x < y)ê°€ ì£¼ì–´ì§„ë‹¤. 
// xë²ˆ ì¹¸ì— ë„ì°©í•˜ë©´, yë²ˆ ì¹¸ìœ¼ë¡œ ì´ë™í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.
for(int i=0; i<N; i++) {
    String[] ladders = br.readLine().split(" ");
    next[Integer.parseInt(ladders[0])] = Integer.parseInt(ladders[1]);
}

// ë‹¤ìŒ Mê°œì˜ ì¤„ì—ëŠ” ë±€ì˜ ì •ë³´ë¥¼ ì˜ë¯¸í•˜ëŠ” u, v (u > v)ê°€ ì£¼ì–´ì§„ë‹¤. 
// uë²ˆ ì¹¸ì— ë„ì°©í•˜ë©´, vë²ˆ ì¹¸ìœ¼ë¡œ ì´ë™í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.
for(int i=0; i<M; i++) {
    String[] snakes = br.readLine().split(" ");
    next[Integer.parseInt(snakes[0])] = Integer.parseInt(snakes[1]);
}
```

ì˜ˆì œ ì…ë ¥ 1ì˜ ì˜ˆì‹œì— ë”°ë¥´ë©´, next ë°°ì—´ì€ ì•„ë˜ì™€ ê°™ì€ êµ¬ì¡°ë¥¼ ê°€ì§ˆ ê²ƒì´ë‹¤.

```
- next[32] = 62
- next[42] = 68
...
- next[95] = 13
...
- next[75] = 19
...
```

### 3. BFS ì‚¬ìš©

ìµœì†Œ ê±°ë¦¬ë¥¼ êµ¬í•œë‹¤ëŠ” ê²ƒì€ ë¬´ì¡°ê±´ BFSë¥¼ ì‚¬ìš©í•˜ë¼ëŠ” ì˜ë¯¸ë¡œ ë³´ë©´ ëœë‹¤.  
ì²˜ìŒ ì‹œì‘ ê°’ì¸ 1ì„ íì— ë„£ì–´ë‘ê³ , ì£¼ì‚¬ìœ„(1ë¶€í„° 6)ë¥¼ êµ´ë ¤ê°€ë©° 100ê¹Œì§€ ì´ë™í•˜ëŠ” ìµœë‹¨ ê±°ë¦¬ë¥¼ ì°¾ìœ¼ë©´ ëœë‹¤. ë‹¨, "100ë²ˆ ì¹¸ì„ ë„˜ì–´ê°„ë‹¤ë©´ ì´ë™í•  ìˆ˜ ì—†ë‹¤"ëŠ” ì¡°ê±´ì´ ìˆê¸° ë•Œë¬¸ì—, ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ ì´ë™í•œ ì¹¸ì´ 100ì„ ë„˜ì–´ê°€ì„œëŠ” ì•ˆëœë‹¤.  


```java
...
while(!queue.isEmpty()) {
    int location = queue.poll();
    for(int i=1; i<=6; i++) {
        int nextLocation = location + i;

        // ë§Œì•½ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦° ê²°ê³¼ê°€ 100ë²ˆ ì¹¸ì„ ë„˜ì–´ê°„ë‹¤ë©´ ì´ë™í•  ìˆ˜ ì—†ë‹¤.
        if(nextLocation <= 100) {

            // ì‚¬ë‹¤ë¦¬ í˜¹ì€ ë±€ì´ ì¡´ì¬í•œë‹¤ë©´, í•´ë‹¹ ìœ„ì¹˜ë¡œ ì´ë™
            // ë§Œì•½ ì—†ë‹¤ë©´ ìê¸° ìì‹ ì´ ê·¸ëŒ€ë¡œ ê°’ì´ ë  ê²ƒì´ë‹¤.
            nextLocation = next[nextLocation];
            
            // ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ìš° -> ì´ë™íšŸìˆ˜ + 1
            // BFS -> ê°€ì¥ ë¨¼ì € í•´ë‹¹ ì¹¸ì„ ë°©ë¬¸í–ˆë‹¤ = ê°€ì¥ ì ì€ íšŸìˆ˜ë¡œ í•´ë‹¹ ì¹¸ìœ¼ë¡œ ì´ë™í–ˆë‹¤ëŠ” ì˜ë¯¸
            if(dist[nextLocation] < 0) {
                dist[nextLocation] = dist[location] + 1;
                queue.offer(nextLocation);
            }
        }
    }
}
return dist[100];
```
